C++学习提高篇(2)——重载、覆盖、隐藏
==========

转载自：[klose的新浪博客](http://blog.sina.com.cn/s/blog_4a1f59bf0100ld1y.html)

成员函数的`重载、覆盖(override)与隐藏`很容易混淆，C++程序员必须要搞清楚概念，否则错误将防不胜防。

**成员函数被`重载`的特征：**

* 相同的范围（在同一个类中）；
* 函数名字相同；
* 参数不同；
* virtual 关键字可有可无。

**`覆盖`：派生类函数覆盖基类函数，特征是：**

* 不同的范围（分别位于派生类与基类）；
* 函数名字相同；
* 参数相同；
* 基类函数必须有`virtual`关键字。

函数`Base::f(int)`与`Base::f(float)`相互重载，而`Base::g(void)`被`Derived::g(void)`覆盖。

    #include <iostream.h>
    class Base
    {
    public:
        void f(int x){ cout << "Base::f(int) " << x << endl; }
        void f(float x){ cout << "Base::f(float) " << x << endl; }
        virtual void g(void){ cout << "Base::g(void)" << endl;}
    };
    class Derived : public Base
    {
    public:
        virtual void g(void){ cout << "Derived::g(void)" << endl;}
    };
    void main(void)
    {
        Derived d;
        Base *pb = &d;
        pb->f(42); // Base::f(int) 42
        pb->f(3.14f); // Base::f(float) 3.14
        pb->g(); // Derived::g(void)
    }

**隐藏：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：**

1. **如果派生类的函数与基类的函数同名，但是参数不同**。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

1. 函数Derived::f(float)覆盖了Base::f(float)。
2. 函数Derived::g(int)隐藏了Base::g(float)，而不是重载。
3. 函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。

> 很多C++程序员没有意识到有`隐藏`这回事。由于认识不够深刻，`隐藏`的发生可谓神出鬼没，常常产生令人迷惑的结果。`bp`和`dp`指向同一地址，按理说运行结果应该是相同的，可事实并非这样。

    #include <iostream.h>
    class Base
    {
    public:
        virtual void f(float x){ cout << "Base::f(float) " << x << endl; }
        void g(float x){ cout << "Base::g(float) " << x << endl; }
        void h(float x){ cout << "Base::h(float) " << x << endl; }
    };
    class Derived : public Base
    {
    public:
        virtual void f(float x){ cout << "Derived::f(float) " << x << endl; }
        void g(int x){ cout << "Derived::g(int) " << x << endl; }
        void h(float x){ cout << "Derived::h(float) " << x << endl; }
    };
    
    void main(void)
    {
        Derived d;
        Base *pb = &d;
        Derived *pd = &d;
        // Good : behavior depends solely on type of the object
        pb->f(3.14f); // Derived::f(float) 3.14
        pd->f(3.14f); // Derived::f(float) 3.14
        // Bad : behavior depends on type of the pointer
        pb->g(3.14f); // Base::g(float) 3.14
        pd->g(3.14f); // Derived::g(int) 3 (surprise!)
        // Bad : behavior depends on type of the pointer
        pb->h(3.14f); // Base::h(float) 3.14 (surprise!)
        pd->h(3.14f); // Derived::h(float) 3.14
    }


**摆脱隐藏**

隐藏规则引起了不少麻烦。示例程序中，语句`pd->f(10)`的本意是想调用函数`Base::f(int)`，但是`Base::f(int)`不幸被`Derived::f(char *)`隐藏了。由于数字10不能被隐式地转化为字符串，所以在编译时出错。

    class Base
    {
    public:
        void f(int x);
    };
    class Derived : public Base
    {
    public:
        void f(char *str);
    };
    void Test(void)
    {
        Derived *pd = new Derived;
        pd->f(10); // error
    }

从示例看来，隐藏规则似乎很愚蠢。但是隐藏规则至少有两个存在的理由：写语句`pd->f(10)`的人可能真的想调用`Derived::f(char *)`函数，只是他误将参数写错了。有了隐藏规则，编译器就可以明确指出错误，这未必不是好事。否则，编译器会静悄悄地将错就错，程序员将很难发现这个错误，流下祸根。假如类`Derived`有多个基类(多重继承)，有时搞不清楚哪些基类定义了函数`f`。如果没有隐藏规则，那么`pd->f(10)`可能会调用一个出乎意料的基类函数`f`。尽管 隐藏规则看起来不怎么有道理，但它的确能消灭这些意外。

如果语句`pd->f(10)`一定要调用函数`Base::f(int)`，那么将类`Derived`修改为如下即可。

    class Derived : public Base
    {
    public:
        void f(char *str);
        void f(int x) { Base::f(x); }
    };

